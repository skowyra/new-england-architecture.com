<?php

declare(strict_types=1);

use Drupal\Component\Render\HtmlEscapedText;
use Drupal\Component\Render\MarkupInterface;
use Drupal\Core\Render\RendererInterface;
use Drupal\Component\Serialization\Json;
use Drupal\Component\Utility\NestedArray;
use Drupal\Core\Entity\ContentEntityInterface;
use Drupal\Core\Field\EntityReferenceFieldItemList;
use Drupal\Core\Template\Attribute;
use Symfony\Component\String\UnicodeString;

/**
 * Implements hook_extension().
 */
function semi_coupled_extension(): string {
  return '.html.twig';
}

/**
 * Implements hook_theme().
 */
function semi_coupled_theme(array $existing, string $type, string $theme, string $path): array {
  return drupal_find_theme_templates($existing, semi_coupled_extension(), $path);
}

/**
 * Implements hook_render_template().
 *
 * @see themes/engines/semi_coupled/README.md
 */
function semi_coupled_render_template(string $template_file, array $variables): string|MarkupInterface {
  // If the template is not provided by the canvas_stark theme, render with Twig.
  if (!str_contains($template_file, '/process_as_jsx/')) {
    /* @phpstan-ignore function.notFound */
    return twig_render_template($template_file, $variables);
  }

  // If we've reached this point, the template filename ends with `--canvascanvas` and the
  // template contents should be a JSON object that maps render array properties
  // to the data types they should be treated as when sent to React.
  $file_contents = file_get_contents($template_file);
  if ($file_contents === FALSE) {
    $file_contents = '';
  }

  $info = Json::decode($file_contents);
  $props = [];
  $slots = [];
  _semi_coupled_collect_props($props, $slots, $info['props'], $variables);

  $renderer = \Drupal::service('renderer');
  $tag_name = 'drupal-' . basename($template_file, semi_coupled_extension());

  // Items with the property `children` will be overwritten in React if the
  // component has children. We copy those slots and props to a "renderChildren"
  // property so those values can get to the component intact.
  if (isset($slots['children'])) {
    $slots['renderChildren'] = $slots['children'];
  }

  // This is a render element that begins with a custom element based on the
  // template name. So if the template name was foo--bar the markup for this
  // element would be:

  // <drupal-foo--bar attribute1="fizz" attribute2="buzz">
  // [THE CHILDREN, WHICH COULD BE OTHER CUSTOM TAGS OR REGULAR HTML]
  // </drupal-foo--bar>
  //
  // In the front-end application, these tags are mapped to React components,
  // and the attributes are converted to the props received by that component.
  $element = _semi_coupled_build_html_tag($tag_name, $props, $slots, $renderer);

  return $renderer->render($element);
}

/**
 * Returns an 'html_tag' render element with the requested props and slots.
 */
function _semi_coupled_build_html_tag(string $name, array $props, array $slots, RendererInterface $renderer): array {
  // Build the slot elements.
  $slot_elements = [];
  foreach ($slots as $slot_name => $slot) {
    if (is_array($slot)) {
      $content = $renderer->render($slot);
    }
    elseif ($slot instanceof MarkupInterface) {
      $content = $slot;
    }
    elseif (is_scalar($slot) || $slot instanceof \Stringable) {
      $content = new HtmlEscapedText((string) $slot);
    }
    else {
      $content = '';
    }
    if ((string) $content !== '') {
      // Wrap the slots in drupal-html-fragment, which is converted to a
      // fragment for whatever client side framework is rendering this markup.
      // It is wrapped in a fragment to ensure only one top-level parent is sent
      // to be rendered.
      $slot_elements[$slot_name] = [
        '#type' => 'html_tag',
        '#tag' => 'drupal-html-fragment',
        '#attributes' => new Attribute(['slot' => $slot_name]),
        '#value' => $content,
      ];
    }
  }

  // Build the prop attributes.
  $prop_attributes = new Attribute();
  foreach ($props as $js_name => $value) {
    $html_name = _semi_coupled_kebab_case($js_name);
    $prop_attributes[$html_name] = Json::encode($value);
  }

  // Build the complete element.
  $element = [
    '#type' => 'html_tag',
    '#tag' => $name,
    '#attributes' => $prop_attributes,
    '#value' => $renderer->render($slot_elements),
  ];

  return $element;
}

/**
 * @param array $props
 *   The array that prop data will be added to.
 * @param array $slots
 *   The array that slot data will be added to.
 * @param array $prop_types
 *   Prop names and definition as defined by the 'props' config in the JSON
 *   returned by the `--canvas.html.twig` template being rendered.
 * @param array|object $variables
 *   The variables array provided to the template or a subset of it.
 * @param array $parents
 *   Keeps track of where within the $variables array we are accessing.
 *
 * @return void
 */
function _semi_coupled_collect_props(array &$props, array &$slots, array $prop_types, array|object $variables, array $parents = []): void {
  foreach ($prop_types as $name => $type) {
    // Get the semi-coupled-friendly value associated with $name from the
    // $variables array.
    $variable = _semi_coupled_get_variable($variables, $name);
    if (!isset($variable)) {
      continue;
    }
    $new_parents = [...$parents, $name];

    // If the type is an array, then the JSON props spec has nested properties
    // that need to be retrieved recursively.
    if (is_array($type)) {
      if (is_iterable($variable)) {
        // Sequence.
        if (count($type) === 1 && (isset($type[0]) || isset($type['*']))) {
          foreach ($variable as $i => $item) {
            _semi_coupled_collect_props($props, $slots, $type[0] ?? $type['*'], $item, [...$new_parents, $i]);
          }
        }
        // Map.
        else {
          _semi_coupled_collect_props($props, $slots, $type, $variable, $new_parents);
        }
      }
    }
    elseif ($type === 'JSX.Element') {
      // If the type is defined as `JSX.Element`, it goes into a slot for
      // eventual rendering.
      $slots[implode('.', $new_parents)] = $variable;
    }

    // When an object has a `toArray` method, use that as the means to getting
    // the prop values.
    // For example, \Drupal\Core\Template\Attribute.
    elseif ($type === 'object' && is_object($variable) && method_exists($variable, 'toArray')) {
      $value = $variable->toArray();
      if (!empty($value)) {
        NestedArray::setValue($props, $new_parents, $value);
      }
      else {
        NestedArray::setValue($props, $new_parents, new stdClass());
      }
    }
    else {
      $value = NULL;
      // Were $variable an indexed array it would automatically be converted to
      // an object when sent to JSX. If $variable is empty it will remain an
      // array unless we explicitly set it to an empty object - which is the
      // data type expected by the JSX.
      if ($type === 'object' && $variable === []) {
        $value = new stdClass();
      }
      elseif ($type === 'string') {
        try {
          $value = (string) $variable;
        }
        // @phpstan-ignore catch.neverThrown
        catch (\Exception) {
          // For example, \Drupal\Core\Url.
          if (is_object($variable) && method_exists($variable, 'toString')) {
            $value = $variable->toString();
          }
        }
      }
      else {
        $value = $variable;
      }
      NestedArray::setValue($props, $new_parents, $value);
    }
  }
}

/**
 * Returns a single named variable from an array or object.
 *
 *  Values within render arrays might be inside structures like field data,
 *  entity references, or simple object properties. These values are extracted
 *  here so they are available to the client side rendering process.
 *
 * @param array|object $variables
 *   A render array or something found deeper within it.
 * @param string $index_in_js_format
 *   The index of the where in $variables our data might be.
 *
 * @return mixed
 *   Essentially $variables[~$index_in] or $variables->{~$index_in}.
 */
function _semi_coupled_get_variable(array|object $variables, string $index_in_js_format): mixed {
  // The lookup information we have is camelCased, but the values are likely
  // in snake case, so we create a snake case formatted index.
  $index_in_php_format = _semi_coupled_snake_case($index_in_js_format);
  if (is_array($variables)) {
    // If the index provided is an index of $variables, that is all we need.
    if (isset($variables[$index_in_php_format])) {
      return $variables[$index_in_php_format];
    }
    // If the index is `value` of an array with only one item, we can assume
    // the contents of 'value' has the desired content. For example a `uri`
    // array is structured ['uri']['value'] => 'http://THE-URI'.
    elseif ($index_in_php_format === 'value' && count($variables) === 1 && isset($variables[0]['value'])) {
      return $variables[0]['value'];
    }
    // If the index prefixed by '#' exists, it is a render array property and
    // should be returned.
    elseif (isset($variables['#' . $index_in_php_format])) {
      return $variables['#' . $index_in_php_format];
    }
  }
  // If the structure we are evaluating is an object, attempt to extract the
  // values from it by approaches such as accessing the properties as methods.
  elseif (is_object($variables)) {
    $method_name = $index_in_js_format;
    // If the index exists as a method on this object and can be called, then
    // return the value of that invocation.
    if (is_callable([$variables, $method_name])) {
      return $variables->$method_name();
    }
    elseif ($variables instanceof EntityReferenceFieldItemList && $method_name === 'entity') {
      // We wind up here if the $variables object represents one or more entity
      // references.
      $referenced_entities = $variables->referencedEntities();

      // The referenced entities will have their data made available as their
      // 'toArray' form when possible.
      // @phpstan-ignore-next-line function.alreadyNarrowedType
      $entity_summaries = array_map(fn($entity) => method_exists($entity, 'toArray') ? $entity->toArray() : $entity, $referenced_entities);

      // To avoid unnecessary nesting, single-result entity references are not
      // returned inside an array.
      return count($entity_summaries) === 1 ? $entity_summaries[0] : $entity_summaries;
    }
    elseif ($variables instanceof ContentEntityInterface && $variables->hasField($index_in_js_format)) {
      // The index might represent a field name. This extracts the value of the
      // field, but wrapped in a try block so if $index_in_js_format is not a
      // valid field name, an exception does not stop this process entirely.
      try {
        $field_content = $variables->get($index_in_js_format);
        $values = array_map(fn($item) => $item['value'], $field_content->getValue());
        // To avoid unnecessary nesting, single-result values are not returned
        // inside an array.
        return count($values) <= 1 ? $values[0] : $values;
      }
      catch (\Throwable) {
        // Intentionally empty.
      }
    }
    // If the camel cased index is available as a public property, return the
    // value of that.
    elseif (isset($variables->$index_in_js_format)) {
      return $variables->$index_in_js_format;
    }
    // If the snake cased index is available as a public property, return the
    // value of that.
    elseif (isset($variables->$index_in_php_format)) {
      return $variables->$index_in_php_format;
    }
  }
  return NULL;
}

/**
 * Converts a string to snake case (all lowercase, words separated with '_').
 *
 * Snake case is the convention for PHP variable names.
 */
function _semi_coupled_snake_case(string $string): string {
  return ((string) (new UnicodeString($string))->snake());
}

/**
 * Converts a string to kebab case (all lowercase, words separated with '-').
 *
 * Kebab case is the convention for HTML attribute names.
 */
function _semi_coupled_kebab_case(string $string): string {
  return str_replace('_', '-', _semi_coupled_snake_case($string));
}
